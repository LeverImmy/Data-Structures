## LAB1 报告

### 01.cpp

**错误类型**：Runtime Error

**错误原因**：在 `play(int)` 函数中，在消去了长度大于等于 $3$ 的珠子之后，会递归调用 `play(left - 1)`，检查 `left` 左侧的珠子是否也能被继续消掉。但当 `left == 0` 时，即左侧没有更多珠子时，`play(left - 1)` 会导致 `char color = a.at(-1);` 被调用，这会导致下标不合法而报错 Runtime Error。

**如何构造**：构造一组数据使得最左侧珠子被消去。

```
A
2
0 A
1 A
```

### 02.cpp

**错误类型**：Runtime Error

**错误原因**：在 `play(int)` 函数中，在消去了长度大于等于 $3$ 的珠子之后，会调用 `a.erase(left, size)` 消去这一次的珠子，并递归调用 `play(next)`，检查 `left` 左侧的珠子是否也能被继续消掉。但当 `next == 0` 时，即左侧没有更多珠子时，`play(next)` 会导致 `char color = a.at(0);` 被调用。但此时 `a` 为空！这会导致下标不合法而报错 Runtime Error。

**如何构造**：构造一组数据使得所有珠子全被一次消去。

```
A
2
0 A
1 A
```

### 03.cpp

**错误类型**：Time Limit Exceeded

**错误原因**：由于 `std::string` 里的 `erase()` 方法的时间复杂度为 $O(n)$，所以 $m$ 次操作的时间复杂度为 $O(nm)$。由于 $n, m \le 5 \times 10^5$，因此肯定会导致超时。

**如何构造**：构造一组 $n = 5 \times 10^5, m = 2.5 \times 10^5$ 的数据，使得每次插入后被消去的珠子都是最左侧的三颗。

### 04.cpp

**错误类型**：Wrong Answer

**错误原因**：在 `play()` 函数中，如果插入的珠子和原本位于 `rank` 的珠子相同，代码

```cpp
while (left > 0 && a.at(left) == color) --left;
```

就一定会运行一次，但是此时标定的“同一种珠子”的范围就成了 `(left, right)` 为开区间，这是错误的，此时 `size` 会比正确的大小多 $1$，导致长度为 $2$ 的珠子也能被消去。

**如何构造**：构造一组数据，使得插入之后有长度为 $2$ 的珠子串。

```
BA
1
1 A
```

### 05.cpp

**错误类型**：Wrong Answer

**错误原因**：在读入初始珠子串序列时，使用了 `cin` 读入。此时程序无法处理“初始序列为空”的情况，因为 `cin` 会自动忽略空格或换行。

**如何构造**：构造一组数据，满足初始序列为空。

```

1
0 A
```

### 06.cpp

**错误类型**：Wrong Answer

**错误原因**：当一个块的大小超过了块可以容纳的上界时，没有进行重新分块的操作。由于分块数组被定义为 `char p[1 << 12][plen_bound];`，且 `plen_bound` 为 $2^{12}$，数组分配的内存空间是连续的，这会导致如果我们继续插入，则会 **覆盖掉下一个块中的内容**，导致 Wrong Answer。

**如何构造**：原串为 `[1024组AABB]`，然后往第 $2047$ 位插入很多组 `CCDD`，那么这些 `CCDD` 就会覆盖掉第 $512$ 组之后的 `AABB` 导致 Wrong Answer。

### 07.cpp

**错误类型**：Wrong Answer

**错误原因**：由于把整块珠子全部消去时 **并没有移动分块**，所以会导致一些 `plen[i] == 0`，这是一种方便快捷的“伪装删除”的方法。在此之后如果要向左拓展，就不能仅仅 `if (l.second < 0 && l.first >= 0)` 了，而是需要 `while (l.second < 0 && l.first >= 0)` 来跳过所有空块。如果仅仅用块大小补偿一次 `l.second` 的负值，会使 `l.first` 错位导致 Wrong Answer。

**如何构造**：构造三个块大小的串，先连消使第二个块被清空，然后再在第一块和第三块中间插入珠子使得它们可以消去一些珠子，此时就会出错。

### 08.cpp

**错误类型**：Wrong Answer

**错误原因**：没有考虑连消。在消除一次之后，没有考虑新产生的连续的串也会导致消除。

**如何构造**：构造一组会产生连消的数据。

```
BBAAB
1
3 A
```

### 09.cpp

**错误类型**：Runtime Error

**错误原因**：在“执行消除”的过程中，没有考虑被消去的珠子全部在同一块中的情况。如果 `l.first == r.first`，那么 `plen[l.first]` 会被错误地更新。首先它会被更新 `plen[l.first] = l.second + 1;`；紧接着，`int len = plen[r.first] - r.second;` 会被执行。注意此时 $l$ 一定在 $r$ 左侧，所以 `len` 为一个负数！由于 `plen[]` 的类型为 `size_t`，所以语句 `plen[r.first] = len;` 会导致 `plen[r.first]` 变为一个很大的正数。

在之后的 `p2a()` 过程中，由于 `plen[r.first]` 太大，导致 `memcpy(&a[copied], p[i], plen[i]);` 越界访问，报错 Runtime Error。

**如何构造**：构造一组消去的珠子，使得它们全部在同一块中，且前后都有未被消去的珠子。

```
BAAB
1
1 A
```

### 10.cpp

**错误类型**：Wrong Answer

**错误原因**：在“执行消除”的过程中，在将某个块清零的过程中，下面循环的次数是错误的：

```cpp
for (int i = l.first; i < r.first; i++) // 应该从 l.first + 1 开始！
    plen[i] = 0;
```

这样会导致合并后的块也被误删了，导致 Wrong Answer。

**如何构造**：构造一组数据，满足被消除的珠子在不同的块中，且最前面的块不能被全部消完，最后面的块也不能被全部消完，这样才会引发 Wrong Answer。我构造了 `A[1023组BBAA]BBA`，然后在第 $2048$ 的位置上插入 `A`，这样就导致中间的珠子全部消完，正确答案为 `AA`，但 `10.cpp` 输出了 `AB`。
