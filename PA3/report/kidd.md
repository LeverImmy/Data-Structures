## Kidd 解题报告

### 算法原理

虽然 $n$ 最大能达到 $2^{31} - 1$，但由于最多只有 $2m$ 个有效区间端点，所以可以仅仅对这些端点进行离散化处理。这样就解决了值域过大的问题。假设离散化后的区间个数为 `cnt`，那么在 $[0, cnt - 1]$ 上维护一棵线段树，支持区间加一、区间求和的操作即可。

### 细节处理

#### 离散化

读入所有区间端点，并进行排序与去重。

```cpp
int cmp(const void* p1, const void* p2) {
    return *(int*)p1 - *(int*)p2;
}

// 去重
void deduplicate() {
    cnt = 0;
    qsort(raw, 2 * m, sizeof(int), cmp);
    for (int i = 0, j = 0; j < 2 * m; i++) {
        while (raw[j] == raw[i])
            j++;
        raw[i + 1] = raw[j];
        cnt++;
    }
}
```

这样就把 $[1, n]$ 这个过大的区间，离散化为了 $[0, cnt - 1]$ 这个长度不大于 $2m$ 的区间。

#### 线段树的叶结点

在此之后，按照这些端点将有效值域切分为至多 $4m - 1$ 个闭区间。为什么是 **至多** $4m - 1$ 呢？因为如果相邻端点相差 $1$，则不会有新的区间产生。例如端点 $i, i + 1$，只会产生 $[i, i]$ 和 $[i + 1, i + 1]$ 两个闭区间。而 $i, i + k(k > 1)$ 则可以产生 $3$ 个区间：$[i, i], [i + 1, i + k - 1], [i + k, i + k]$。这些区间就能作为线段树的叶结点。

#### 区间加操作

如果当前结点表示区间含于操作区间，那么直接对结点进行整体加法，以及对 `add` 标记进行加法。

否则，则将 `add` 标记下传，然后分别递归操作左子树（如果左子树与操作区间交集非空）和右子树（如果右子树与操作区间交集非空）。

#### 区间求和操作

如果当前结点表示区间含于操作区间，那么直接对结点的和进行返回。

否则，则将 `add` 标记下传，答案为左子树（如果左子树与操作区间交集非空）和右子树（如果右子树与操作区间交集非空）询问之和。

#### 是否开 `long long`

由于答案可能会超过 `int` 能够表示的大小，所以结点维护的区间和需要用 `long long` 存储。以及，在下传 `add` 标记时，由于 `add` 标记乘上区间长度可能会超过 `int` 表示范围，所以需要强制转换为 `long long`。

```cpp
void pushdown(int x) {
    if (add[x]) {
        add[x << 1] += add[x];
        add[x << 1 | 1] += add[x];
        sum[x << 1] += 1LL * add[x] * len[x << 1];
        sum[x << 1 | 1] += 1LL * add[x] * len[x << 1 | 1];
        add[x] = 0;
    }
}
```

### 时空复杂度分析

#### 时间复杂度

离散化的代价为 $O(m \log m)$。

由于单次修改、查询操作最多只会下传最左侧、最右侧一共两条链的 `add` 标记，代价为树高 $O(\log m)$；而本身求和最多也只会递归树高层，所以单次修改、查询操作的代价为 $O(\log m)$。

因此整体的时间复杂度为 $O(m \log m)$。

#### 空间复杂度

由于区间端点个数最多为 $2m$，故生成的区间个数最多为 $4m - 1$。由于线段树只需要至多 $4$ 倍序列长度（区间个数），即 $\approx 16m$ 的空间进行存储，所以整体的空间复杂度为 $O(m)$。