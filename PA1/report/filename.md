## Filename 解题报告

### 算法原理

在 $a$ 中插入等价于在 $b$ 中删除，要想要整体修改次数最少，则二者需要尽可能保证最长公共子序列不变。设 $\text{LCS}(a, b)$ 表示 $a$ 和 $b$ 的最长公共子序列的长度。因此总体需要修改的最少次数为 $n + m - 2\text{LCS}(a, b)$。

设 $f(i, j)$ 表示 $a[1\dots i]$ 和 $b[1\dots j]$ 的最长公共子序列长度。

- 如果 $a_i = b_j$，则 $f(i, j) \gets f(i - 1, j - 1) + 1$。
- 如果 $a_i \neq b_j$，则 $a[1\dots i]$ 和 $b[1\dots j]$ 的最长公共子序列是 $a[1\dots i-1]$ 和 $b[1\dots j]$、$a[1\dots i]$ 和 $b[1\dots j-1]$ 中较长的那一个，所以
  $$
  f(i, j) \gets \max\{f(i - 1, j), f(i, j - 1)\}
  $$

由于插入或删除的次数不会超过 $k$，所以 $f(i, j)$ 最远只会被 $f(i - 1, j - k)$ 和 $f(i - 1, j + k)$ 更新。

### 细节处理

#### 滚动数组优化空间

状态总数是 $O(nm)$ 的，如果直接申请 `f[N][M]` 会导致 MLE。

在实际操作过程中，可以使用 **滚动数组** 的方法来节省空间。由于 $f(i, \cdot)$ 仅与 $f(i - 1, \cdot)$ 有关，所以我们可以考虑只用 **两格** 来存储 $f$ 的第一维。我们将 $f(i, j)$ 存到 `f[i & 1][j]` 中。

#### 调试程序

在测试规模较小的数据时，我尝试将 `f` 数组全部输出，来查看是否达到了我需要的效果，以检查程序的正确性。

### 时空复杂度分析

#### 时间复杂度

由于这一题我采用动态规划的算法，所以时间复杂度可以直接看状态转移的成本以及状态转移的次数。

单次状态转移 $O(1)$，一共最多只有 $O(nk)$ 个状态，所以整体时间复杂度为 $O(nk)$。

#### 空间复杂度

由于使用了滚动数组，所以空间复杂度为 $O(n + m + k)$。

### 另解：时间复杂度为 $O(mk^2)$ 的算法

在做这道题的途中，我还构思过一个时间 $O(mk^2)$ 的算法。

#### 算法原理

设 $f(i, j, l)$ 表示 $a[1 \dots i]$ 能否经过 $j$ 次插入，$l$ 次删除，得到 $b[1 \dots i]$。

我们考虑 $b[i]$ 和 $a[i + l - j]$（$a[i]$ 经过 $j$ 次插入，$l$ 次删除后对应的位置）。

- 如果 $a[i + l - j] = b[i]$，即当前比较二者相等：
  - 当前比较不引入插入和删除操作:
    $f(i, j, k) \gets f(i - 1, j, l)$，前提是 $i - 1 + j - l \ge 0$。
- 否则：
  - 当前比较是由于一次插入引起的：
    $f(i, j, k) \gets f(i, j, k) \lor f(i - 1, j - 1, l)$，前提是 $j > 0$ 且 $i - 1 + j - 1 - l \ge 0$。
  - 当前比较是由于一次删除引起的：
    $f(i, j, k) \gets f(i, j, k) \lor f(i, j, l - 1)$，前提是 $l > 0$。

初值是 $f(1, i, j) \gets [a[1 + i] = b[1 + j]], 0 \le i + j \le k$。`[]` 为 [Iverson bracket](https://en.wikipedia.org/wiki/Iverson_bracket)。

最后只需要考虑答案是什么。进行 $t$ 次修改，那么为了 $a, b$ 的长度相等，实际上进行的插入次数一定是 $\dfrac{m - n + t}{2}$，删除次数一定是 $\dfrac{n - m + t}{2}$。

答案是最小的 $t \in [0, k]$，使得 $f(m, \dfrac{m - n + t}{2}, \dfrac{n - m + t}{2})$ 为真，且 $\dfrac{m - n + t}{2}$ 是整数。如果不存在这样的 $t$，则输出 `-1`。

#### 细节处理

##### 滚动数组优化空间

状态总数是 $O(mk)$ 的，但第二维和第三维的 **最大可能值** 为 $k$，如果直接申请 `f[M][K][K]` 会导致 MLE。

在实际操作过程中，可以使用 **滚动数组** 的方法来节省空间。由于 $f(i, \cdot, \cdot)$ 仅与 $f(i - 1, \cdot, \cdot)$ 有关，所以我们可以考虑只用 **两格** 来存储 $f$ 的第一维。我们将 $f(i, j, k)$ 存到 `f[i & 1][j][k]` 中。

#### 时空复杂度分析

##### 时间复杂度

由于这一题我采用动态规划的算法，所以时间复杂度可以直接看状态转移的成本以及状态转移的次数。

赋初值的时间复杂度为 $O(k^2)$。单次状态转移 $O(1)$，一共最多只有 $O(mk^2)$ 个状态，所以整体时间复杂度为 $O(mk^2)$。

##### 空间复杂度

由于使用了滚动数组，所以空间复杂度为 $O(n + m + k^2)$。
