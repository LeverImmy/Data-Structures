## Match 解题报告

### 算法原理

以 **在序列中的位置** 为关键字、**该位置上对应的字符** 为值，建立 Splay。同时，在每个节点上维护子树对应序列的哈希值，以快速判断子串是否相等。

### 细节处理

#### $n = 0$ 时的情况

当 $n = 0$ 时，输入的初始串为空。如果此时再使用 `scanf("%s", str);` 来读入初始串，则会误读入第一次的操作指令。所以我们需要进行以下修改：

```cpp
scanf("%d %d", &n, &m);
// 如果 n == 0, 则 str 为空串!
if (n)
    scanf("%s", str);
```

#### 如何进行插入

假设要在下标为 $x$ 的结点前插入一个结点。我们将 $x - 1$ 伸展到根，$x$ 伸展到根的右孩子结点：

![insert](https://img.picgo.net/2023/11/20/pa3-19492bd8948bef9e3.jpeg)

此时我们将 $x$ 的左孩子设为新建结点即可。

#### 如何进行删除

假设要删除下标为 $x$ 的结点。我们将 $x - 1$ 伸展到根，$x + 1$ 伸展到根的右孩子结点：

![remove](https://img.picgo.net/2023/11/20/pa3-29456b3786803d62b.jpeg)

此时我们将 $x + 1$ 的左孩子设为空即可。

#### 如何进行区间翻转

我们将 $l - 1$ 伸展到根，$r + 1$ 伸展到根的右孩子结点：

![reverse](https://img.picgo.net/2023/11/20/pa3-3fc54dd7b2920cb5c.jpeg)

此时我们将表示 $[l, r]$ 这段区间的子树的根结点打上 `rev` 标记，表明该子树被翻转。在之后的过程中，如果一个结点被访问到了，就及时将此标记下传即可。在下传的时候，需要交换该结点的左右子树，和该结点的正反哈希值。

#### 如何在区间翻转的情况下判断子串是否相等

我们可以 **维护正反两个方向的哈希值**，从而在翻转后也能快速维护区间哈希值。和区间翻转一样，也是通过伸展操作，将两个待测区间放到根结点的右孩子的左子树上，获取它们的正向哈希值并且进行比较。

#### 增加虚拟结点作为哨兵

由于以上操作可能会遇到 $x - 1, x + 1, l - 1, r + 1$ 不存在的情况，所以在序列最左和最右端增添两个虚拟结点作为哨兵，这样就能保证以上结点均存在。

#### 部分代码实现

我觉得通过 `connect` 函数实现的 Splay 在保持简洁性的同时也不失优美，所以把代码贴在这里：

```cpp
void connect(int p, int f, int o) {
    ch[f][o] = p;
    fa[p] = f;
}
// 旋转 p
void rotate(int p) {
    int f = fa[p], g = fa[f];
    if (g)
        pushdown(g);
    if (f)
        pushdown(f);
    pushdown(p);
    bool o1 = son(p), o2 = son(f);
    connect(ch[p][o1 ^ 1], f, o1);
    connect(f, p, o1 ^ 1);
    connect(p, g, o2);
    pushup(f), pushup(p);
}
// 将 p 伸展至 tar
void splay(int p, int tar) {
    int tarfa = fa[tar];
    while(fa[p] != tarfa) {
        int f = fa[p], g = fa[f];
        if(tarfa != g)
            son(p) ^ son(f) ? rotate(p) : rotate(f);
        rotate(p);
    }
    if(tar == rt)
        rt = p;
}
```

#### 关于哈希

这里的哈希，我使用的底数为 $19260817$，模数为 $10^9 + 7$。即使使用快速幂，也会由于多次进行幂运算而导致超时，所以我预处理了所有可能出现的幂，这样单次计算即为 $O(1)$ 而非 $O(\log n)$。

### 时空复杂度分析

#### 时间复杂度

建树的时间复杂度为 $O(n \log n)$。在 Splay 中单次插入、删除、区间翻转、判断子串是否相等的操作都是均摊 $O(\log n)$ 的，因此总时间复杂度为 $O((n + m)\log n)$。

#### 空间复杂度

由于原字符串长度为 $n$，且最多只会进行 $m$ 次插入，故空间复杂度为 $O(n + m)$。
