## Game 解题报告

### 算法原理

题目大意：给定一个有点权无向图，求 $1$ 号点到 $n$ 号点的最短路径的长度以及数量。

首先将点权转化为边权，然后使用 Dijkstra 算法求出 $1$ 到 $n$ 的最短路，同时在松弛的过程中维护最短路径的数量。

### 细节处理

#### 点权怎么转化为边权

常用的点权转化为边权有两种方式：

1. 一种是将一个点 $u$ 拆成两个点 $u_i$ 和 $u_o$。

    其中所有进入 $u$ 的边都连向 $u_i$，从 $u$ 出去的边都从 $u_o$ 连出，这些边的权值均为 $0$。最后，在 $u_i$ 到 $u_o$ 间连一条长度为 $t_u$ 的边。$1$ 号点到 $n$ 号点的最短路径即为 $1_i$ 到 $n_o$ 的最短路径。

    ```mermaid
    graph LR

    U1((u_i)) --> |t_u|U2((u_o))
    ```
2. 第二种是 $u$ 和 $v$ 之间的边权设置为二者点权的平均值 $\dfrac{1}{2}(t_u + t_v)$。由于进入一个点必然会出去，所以经过某个点 $u$ 的代价恰好为 $t_u$。

    额外地，$1$ 号点、$n$ 号点的点权均只被算了一半，因此最后还需要加上它们。

在实际操作中，我选择了方案二。同时，为了避免求平均值时产生小数，我将所有边权均扩大了一倍，而将最后求得的最短路长度缩小为它的一半即可。

#### 如何求最短路数量

在每次松弛的时候，考虑从前驱 $x$ 到当前结点 $y$ 的边是否已经固定（恰为最短路径）。

- 如果未固定，那么可以松弛，当前结点的最短路数量被更新为前驱的最短路数量；
- 如果已经固定了，恰为最短路径，那么就应累加最短路数量。

```cpp
if (dis[y] > dis[x] + e[i].wt) {
    dis[y] = dis[x] + e[i].wt;
    // 松弛时更新最短路数量
    ans[y] = ans[x];
    if (!vis[y])
        h.push(Pair(y, dis[y]));
} else if (dis[y] == dis[x] + e[i].wt)
    // 长度恰好为最短路长度，累加最短路数量
    ans[y] = (ans[y] + ans[x]) % mod;
```


### 时空复杂度分析

#### 时间复杂度

朴素的 Dijkstra 算法的时间复杂度为 $O(n^2)$。但是，使用堆优化后，每次取出距离最近的需要松弛的点消耗的时间复杂度从原本的 $O(n)$ 降低至 $O(\log n)$，因此总时间复杂度为 $O(n \log n)$。

#### 空间复杂度

由于使用了邻接表来存储图，所以该部分的空间复杂度为 $O(m)$。堆中最多只会有 $n$ 哥结点，因此堆的大小为 $O(n)$。其余的部分，由于只使用了常数个 $O(n)$ 长度的辅助数组，所以空间复杂度为 $O(n)$。

因此，整体的空间复杂度为 $O(n + m)$。