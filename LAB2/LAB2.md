## LAB2 报告

### 不同哈希策略的实现（共 321 字）

#### “坏”的哈希函数

设字符串为 $S[1\dots n]$，$S_i$ 为 $S$ 的第 $i$ 个字符对应的 ASCII 码。构造
$$
h_1(S) = \left(\sum\limits_{i = 1}^nS_i\right) \bmod(\text{table\_size})
$$

#### “好”的哈希函数

记 $p = 19260817$，构造
$$
h_2(S) = \left(\sum\limits_{i = 1}^nS_i\cdot p^{n-i}\right) \bmod(\text{table\_size})
$$

####  双向平方试探策略

维护 `currentDirection` 和 `currentRadius`，分别表示当前试探方向以及试探半径。

- 如果当前试探方向向右，则

  试探半径增加 $1$，往右走 `currentRadius` 的平方加上 `currentRadius - 1` 的平方，下一次试探方向向左。

- 如果当前试探方向向左，则

  往左走两倍的 `currentRadius` 的平方，下一次试探方向向右。

我修改了 `init` 函数，使得初始试探方向向右，试探半径为 $0$。

####  公共溢出区策略

我对 `hashtable::insert` 函数进行了修改，并设置了哈希表大小为 `BIAS = 300007`，公共溢出区即为 `BIAS` 以后的部分。

```cpp
bool insert(hash_entry entry){
    overflow_area *probe_type = dynamic_cast<overflow_area*>(my_collision);
    // 如果为公共溢出区策略，才修改哈希表大小
    if (probe_type)
        table_size = overflow_area::BIAS;
    // ...
}
```

如果发生冲突，即在公共溢出区线性寻找空闲空间进行插入。

```cpp
int overflow_area::operator()(hash_entry* Table, int table_size, int last_choice){
    return BIAS + (++currentLocation);
}
```

### 进行测试（共 243 字）

记 $n$ 为插入次数，$m$ 为查询次数。

#### 测试点 1

- 构造方法

  取较小的 $n$ 和 $m$，随机选取 $n$ 条数据进行插入，然后随机选取 $m$ 个用户名进行查询。

- 数据特征

  $n = 100, m = 200$，数据完全随机。

#### 测试点 2

- 构造方法

  取通过数最靠后的 $n$ 名用户进行插入，因为这些用户通过数均为 $0$，但由于数据量较大，所以导致“姓名不同但做题数相同”的概率会增加，使得哈希冲突的概率增加。

- 数据特征

  $n = 10000, m = 20000$，用户通过数均为 $0$。

#### 测试点 3

- 构造方法

  取较大的 $n$ 和 $m$，随机选取 $n$ 条数据进行插入，然后随机选取 $m$ 个用户名进行查询。

- 数据特征

  $n = 200000, m = 300000$，数据完全随机。

### 分析结果（共 295 字）

1. 当 $n, m$ 较小时，二者差距不大；当 $n, m$ 较大时，“好”的哈希函数更优，因为此时“坏”的哈希函数 **发生哈希冲突概率更大**，导致哈希表需要解决冲突，使运行时间变长。
2. 双向平方试探性能更优。这是因为试探位置的间距将以线性的速度增长，能”尽快跳离”关键码聚集的区段。
3. **封闭散列 **更占优势。但如果哈希表的大小比较小，且存在大量的哈希冲突，公共溢出区策略能避免过多的探测操作以提高效率。
4. 此时使用均匀分布的哈希函数可能导致一些位置长期空闲，而另一些位置发生较多的哈希冲突，使其效率降低。
5. 设置负载因子（哈希表中元素的数量与哈希表大小之比），当其高于阈值时，新建一个更大的哈希表，并将原表内所有元素全部重新插入新表。类似的处理方式也能进行缩容。
