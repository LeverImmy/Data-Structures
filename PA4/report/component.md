## Component 解题报告

### 算法原理

题目要求维护一些不相交集合，支持

1. 合并两个集合；
2. 查询集合内第 $k$ 大数。

其中每次查询操作中的 $k$ 均相同。

我们可以使用 **并查集** 来维护这些堆组成的不相交集合以支持操作 1。由于对于每个询问 $k$ 都是 **固定的**，因此对每个集合我们可以维护一个大小不超过 $k$ 的小根堆，堆顶即为集合内第 $k$ 大数。

### 细节处理

#### 动态扩容

由于每个堆的大小随着加入元素个数的增多将会增长，所以我们使用动态扩容的策略来维护这个以数组为载体实现的堆。每次将容量翻倍，这样能够保证整体扩容的时间复杂度为 $O(n)$。

```cpp
if (_siz == _capacity) {
    for (int i = 1; i <= _siz; i++)
        tmp[i] = val[i];
    delete[] val;
    _capacity <<= 1;
    val = new int[_capacity + 1];
    for (int i = 1; i <= _siz; i++)
        val[i] = tmp[i];
}
```

#### 启发式合并

合并两个堆的时候，首先比较二者大小，然后不断地从较小堆中 `pop()`，并把弹出的元素加入到较大堆中。最后，正确更新较小堆中元素的代表元（此时应该被更新为较大堆的代表元），并用 `delete` 释放较小堆占用的空间。

#### 保证每个堆的大小不超过 $k$

每次向堆内加入新的值的时候，都需要检查一遍堆中元素个数是否已达到 $k$。如果已达到 $k$，那么就要判断新加入元素是否比堆顶元素大。如果比对顶元素大，则对顶元素一定为新集合中第 $k + 1$ 大的元素，我们可以直接将其舍弃。

```cpp
void push(int v) {
    // 如果堆中元素个数已经为 k
    if (_siz == k) {
        // 如果新加入元素比堆顶大，那么就把堆顶丢掉，重新维护第 k 大的值
        if (v > val[1]) {
            pop();
        } else {
            return;
        }
    }
    // ... 其余操作
}
```

### 时空复杂度分析

#### 时间复杂度

因为初始化时新建了 $n$ 个小根堆，因此进行初始化操作的时间复杂度为 $O(n)$。接下来有 $m$ 次操作：

1. 对于合并操作而言，同时使用按秩合并和路径压缩的并查集，单次查询集合代表元所需时间复杂度为 $O(\log^* n)$。

    紧接着，我们还需要对两个堆进行合并，我们规定此时 **秩** 即为堆的大小。由于我们使用的是 **按秩合并**，在每次合并操作时，我们 **将小的堆合并到大的堆中**。这样每次至少有一个堆的大小将变为原来的两倍。所以，每个元素最多只会贡献 $\log n$ 次合并带来的时间复杂度。每次合并的操作为 $O(n \log n)$，故整体时间复杂度为 $O(n \log^2 n)$，即为单次均摊 $O(\log^2 n)$。

2. 对于查询操作

    每次查询需要找到集合代表元，需要 $O(\log^* n)$ 的时间复杂度。然后直接获取该堆堆顶元素的值，需要 $O(1)$ 的时间复杂度。

综上所述，整体的时间复杂度为 $O(m \log^2 n)$。

#### 空间复杂度

由于使用了动态内存管理，所以所有堆中元素个数总和为 $n$，因此空间复杂度为 $O(n)$。

### 一些其他的思考

如果这一题 $k$ 不是固定的，而是每次询问都会变化，那么就不能使用固定大小的堆来维护集合第 $k$ 大值。此时可以考虑使用平衡树，整体的时间复杂度仍为 $O(m\log^2 n)$。